# [从英文中重建数字](https://leetcode-cn.com/problems/reconstruct-original-digits-from-english/)

## 方法：求解非齐次线性方程组

### 思路与算法

首先列表查看每个字母在每个数字中的出现次数。如下表所示：

|      | zero | one  | two  | three | four | five | six  | seven | eight | nine |
| :--: | :--: | :--: | :--: | :---: | :--: | :--: | :--: | :---: | :---: | :--: |
|  e   |  1   |  1   |      |   2   |      |  1   |      |   2   |   1   |  1   |
|  f   |      |      |      |       |  1   |  1   |      |       |       |      |
|  g   |      |      |      |       |      |      |      |       |   1   |      |
|  h   |      |      |      |   1   |      |      |      |       |   1   |      |
|  i   |      |      |      |       |      |  1   |  1   |       |   1   |  1   |
|  n   |      |  1   |      |       |      |      |      |   1   |       |  2   |
|  o   |  1   |  1   |  1   |       |  1   |      |      |       |       |      |
|  r   |  1   |      |      |   1   |  1   |      |      |       |       |      |
|  s   |      |      |      |       |      |      |  1   |   1   |       |      |
|  t   |      |      |  1   |   1   |      |      |      |       |   1   |      |
|  u   |      |      |      |       |  1   |      |      |       |       |      |
|  v   |      |      |      |       |      |  1   |      |   1   |       |      |
|  w   |      |      |  1   |       |      |      |      |       |       |      |
|  x   |      |      |      |       |      |      |  1   |       |       |      |
|  z   |  1   |      |      |       |      |      |      |       |       |      |

这里我们令**未知量** $f(i)$ 表示数字 $i$ 出现的次数，令**已知量** $N(letter)$ 表示字母出现的次数。得下列等式：
$$
\begin{cases}
	f(0)+f(1)+2f(3)+f(5)+2f(7)+f(8)+f(9)=N(e)\\
	f(4)+f(5)=N(f)\\
	f(8)=N(g)\\
	f(3)+f(8)=N(h)\\
	f(5)+f(6)+f(8)+f(9)=N(i)\\
	f(1)+f(7)+2f(9)=N(n)\\
	f(0)+f(1)+f(2)+f(4)=N(o)\\
	f(0)+f(3)+f(4)=N(r)\\
	f(6)+f(7)=N(s)\\
	f(2)+f(3)+f(8)=N(t)\\
	f(4)=N(u)\\
	f(5)+f(7)=N(v)\\
	f(2)=N(w)\\
	f(6)=N(x)\\
	f(0)=N(z)
\end{cases}
\tag{1}
$$
写成矩阵乘积形式如下，题意即转换为求取矩阵参数；（题意已经说明了保证有唯一解）
$$
\left[
\begin{matrix}
   1 & 1 & 0 & 2 & 0 & 1 & 0 & 2 & 1 & 1\\
   0 & 0 & 0 & 0 & 1 & 1 & 0 & 0 & 0 & 0\\
   0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 1 & 0\\
   0 & 0 & 0 & 1 & 0 & 0 & 0 & 0 & 1 & 0\\
   0 & 0 & 0 & 0 & 0 & 1 & 1 & 0 & 1 & 1\\
   0 & 1 & 0 & 0 & 0 & 0 & 0 & 1 & 0 & 2\\
   1 & 1 & 1 & 0 & 1 & 0 & 0 & 0 & 0 & 0\\
   1 & 0 & 0 & 1 & 1 & 0 & 0 & 0 & 0 & 0\\
   0 & 0 & 0 & 0 & 0 & 0 & 1 & 1 & 0 & 0\\
   0 & 0 & 1 & 1 & 0 & 0 & 0 & 0 & 1 & 0\\
   0 & 0 & 0 & 0 & 1 & 0 & 0 & 0 & 0 & 0\\
   0 & 0 & 0 & 0 & 0 & 1 & 0 & 1 & 0 & 0\\
   0 & 0 & 1 & 0 & 0 & 0 & 0 & 0 & 0 & 0\\
   0 & 0 & 0 & 0 & 0 & 0 & 1 & 0 & 0 & 0\\
   1 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0
\end{matrix}
\right]
\left[
\begin{matrix}
   f(0) \\
   f(1) \\
   f(2) \\
   f(3) \\
   f(4) \\
   f(5) \\
   f(6) \\
   f(7) \\
   f(8) \\
   f(9) 
\end{matrix}
\right]
=
\left[
\begin{matrix}
   N(e) \\ N(f) \\ N(g) \\ N(h) \\ N(i) \\ N(n) \\ N(o) \\
   N(r) \\ N(s) \\ N(t) \\ N(u) \\N(v) \\N(w) \\N(x) \\N(z)
\end{matrix}
\right]
\tag{2}
$$
解得：
$$
\begin{cases}
	f(0)=N(z)\\
	f(1)=N(o)-N(z)-N(w)-N(u)\\
	f(2)=N(w)\\
	f(3)=N(h)-N(g)\\
	f(4)=N(u)\\
	f(5)=N(v)+N(x)-N(s)\\
	f(6)=N(x)\\
	f(7)=N(s)-N(x)\\
	f(8)=N(g)\\
	f(9)=N(i)+N(s)-N(v)-2N(x)-N(g)
\end{cases}
\tag{1}
$$
我们可以用``unordered_map``统计各个字母出现次数。

### 代码

```c++
class Solution {
public:
    string originalDigits(string s) {
        unordered_map<char,int> mp;
        string res;
        for(char& ch:s)
            mp[ch]++;
        vector<int> num_c(10,0);
        num_c[0]=mp['z'];
        num_c[1]=mp['o']-mp['z']-mp['w']-mp['u'];
        num_c[2]=mp['w'];
        num_c[3]=mp['h']-mp['g'];
        num_c[4]=mp['u'];
        num_c[5]=mp['v']+mp['x']-mp['s'];
        num_c[6]=mp['x'];
        num_c[7]=mp['s']-mp['x'];
        num_c[8]=mp['g'];
        num_c[9]=mp['i']+mp['s']-mp['v']-2*mp['x']-mp['g'];
        for(int i=0;i<10;i++){
            int n=num_c[i];
            while(n-->0){
                res.push_back('0'+i);
            }
        }
        return res;
    }
};
```

### 复杂度分析

- **时间复杂度：**$O(N)$，$N$为字符串长度，因为要遍历所以时间复杂度为$O(N)$。
- **空间复杂度：**$O(S)$，$S$为重建之后的数字个数。
